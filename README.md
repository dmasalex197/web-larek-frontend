# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/styles/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```

## Описание сайта (процессы в проекте)
* На главной странице список товаров;
* Модальное окно с детальным описанием товара;
* Возможность положить товар в корзину, если он не был добавлен раньше (удалить из нее товар);
* Корзина, товары в ней;
* Заказ: адрес, способ оплаты, почта и телефон покупателя, 
* После оплаты товар удаляется из корзины

## Классы, типы и интерфейсы

### Интерфейс карточки товара
```
interface ICard {
	id: string;
	description: string;
	image: string;
    title: string;
    category: string;
	price: number | null;
}
```
### Способ оплаты
```
enum Payment {
    online = 'онлайн',
    receipt = 'при получении',
} 
```
### Интерфейс заказа POST запрос
```
interface IOrder {
    payment: Payment;
    email: string;
    phone: number;
	adress: string;
    total: number;
	items: string[];
}
```
### Интерфейс списка заказов
```
interface ICards {
    total: number;
    items: ICard[];
}
```
### Интерфейсы ошибок API
```
interface errorAPI {
    error: string;
}
```
### Интерфейс подтверждения заказа 
```
interface ISuccessOrder {
    id: string;
    total: number
}
```
### Интерфейс АПИ клиента
```
interface ICardAPI {
    getCards: () => Promise<ICards>;
    getCard: (id: string) => Promise<ICard>;
    orderCards: (order: IOrder) => Promise<ISuccessOrder>;
}
```
### Интерфейс корзины
interface IBasket {
	basketTotal: number;
	title: string;
	items: ICard[];
}

### Интерфейс для модели данных товаров
```
interface ICardModel {
    cards: ICard[];
    preview: string | null;
    loadCards(): Promise<void>;
    getCardById(cardId: string): Promise<ICard>;
}
```
### Интерфейс для модели данных корзины
```
interface IBasketModel {
    total: number;
    cards: Map<string, number>;
    add(id: string): void;
    remove(id: string): void;
    clear(): void;
}
```

### Интерфейс для модели данных приложения
```
intaface AppState {

}
```

## Архитектура приложения
Код приложения разделен на слои согласно парадигме MVP.
- слой представления, отвечает за отображение данных на странице;
- слой данных, отвечает за хранение данных;
- презентер,отвечает за связь представления и данных.

### Базовый код

#### Класс API
Содержит в себе базовую логику отправки запросов.
В конструктор передается базовый адрес сервера и опциональный объект с заголовками запросов.
Методы:
-`get` - выполняет запрос на переданной в параметрах ендпоинт и возвращает промис с объектом,которым ответил сервер.
-`post`- принимает объект с данными,которые будут переданы в JSON в теле запроса, и отправляет эти данные на ендпоинт переданный как параметр при вызове метода. По умолчанию выполняется `POST` запрос, но метод запроса может быть переопределен заданием третьего параметра при вызове.

####  Класс EventEmitter
Брокер событий позволяет отправлять события и подписываться на события, происходящие в системе. Класс используется в презентере для обработки событий и в слоях приложения для генерации событий.  
Основные методы, реализуемые классом описаны интерфейсом `IEvents`:
- `on` - подписка на событие
- `emit` - инициализация события
- `trigger` - возвращает функцию, при вызове которой инициализируется требуемое в параметрах событие  

## Слой данных

#### Класс Cards

Класс отвечает за логику работы с данными карточек.\
Конструктор класса принимает инстант брокера событий.\
В полях класса хранятся следующие данные:
-_cards:ICard[]- массив объектов карточек
-_preview:string|null- id карточки, выбранной для просмотра.


#### Класс IOrder

Класс отвечает за хранение и логику работы с данными пользователя.\
Конструктор класса принимает инстант брокера событий.\
В полях класса хранятся следующие данные:
-payment: string - Выбор способа оплаты заказа
-adress:string - Адрес доставки
-email: string -  Электронная почта пользователя
-phone: number - Телефон пользователя


### Классы представления

Все классы представления отвечают за отображение внутри контейнера (DOM-элемент)
передаваемых в них данных.

#### Класс Modal 

Реализует модальное окно. Также представляет методы `open` и `close` для управления отображения модального окна.
Устанавливает слушатели на клик в оверлей и на кнопку крестик для закрытия попапа.
-constructor(selector:string, events:IEvents) Конструктор принимает селектор, по которому в разметке страницы будет идентифицировано модальное окно и экземпляр класса `EventEmmiter` для возможности инициаций событий.

Поля класса
-modal: HTMLElement-элемент модального окна
-events:IEvents-брокер событий

#### Класс AppState
Реализована единая модель данных приложения в файле src/components/model/AppState.ts, содержащая всю логику работы с данными и возможные действия над ними. Все изменения данных происходят через методы модели, а она в свою очередь уведомляет об изменениях через метод настроек onChange(changes: AppStateChanges) чтобы не зависеть от конкретного способа коммуникации между компонентами. Подключение модели к системе событий производится через обертку src/components/model/AppStateEmitter.ts.

Экземпляр модели передается в контроллеры, которые по факту являются обработчиками пользовательских действий и обновляют состояние модели через ее методы. Экземпляры контроллеров передаются в качестве объекта содержащего обработчики событий в верхнеуровневые отображения (экраны).

При обработке событий возникающих в AppStateEmitter производится обновление данных в верхнеуровневых отображениях. Экраны это фактически крупные сборки инкапсулирующие детали реализации интерфейса и принимающие из вне только обработчики событий и необходимые данные. Экраны внутри составлены из более мелких отображений, которые инициализируют с помощью глобальных настроек проекта и распределяют данные между вложенными отображениями через свойства и метод render().

#### Отображения
Отображения в проекте разделены на три типа:
 • common — общие компоненты, не зависящие от доменной области проекта
 • partial — частичные компоненты, реализующие доменную область проекта
 • screen — верхнеуровневые компоненты, которые являются экранами приложения
Первые два типа (common и partial) независимо типизированы, не используют глобальных настроек напрямую и могут быть легко переносимы между проектами. Экраны (screen) же зависят от глобальных настроек и используют их для инициализации и передачи данных между вложенными отображениями, так как по факту это соединительный код для удобства вынесенные в отдельные файлы и оформленный как отображение.

#### Модели

Модели в проекте представлены классом AppState, который содержит в себе все данные и логику работы с ними. Модель частично реализует паттерн "Наблюдатель", и уведомляет об изменениях через метод onChange(changes: AppStateChanges). Для удобства работы с данными в модели реализованы методы для изменения данных, которые в свою очередь вызывают метод onChange().

#### Контроллеры
Контроллеры в проекте представлены классами унаследованными от Controller, и являются обработчиками пользовательских действий и обновляют состояние модели через ее методы. Контроллеры принимают в себя экземпляр модели и обрабатывают события, вызывая методы модели для изменения данных.
